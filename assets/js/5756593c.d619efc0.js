(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2268],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return c}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=i.createContext({}),s=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=s(e.components);return i.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),u=s(n),c=r,y=u["".concat(d,".").concat(c)]||u[c]||p[c]||o;return n?i.createElement(y,a(a({ref:t},l),{},{components:n})):i.createElement(y,a({ref:t},l))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=u;var m={};for(var d in t)hasOwnProperty.call(t,d)&&(m[d]=t[d]);m.originalType=e,m.mdxType="string"==typeof e?e:r,a[1]=m;for(var s=2;s<o;s++)a[s]=n[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6888:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return m},contentTitle:function(){return d},metadata:function(){return s},toc:function(){return l},default:function(){return u}});var i=n(2122),r=n(9756),o=(n(7294),n(3905)),a=["components"],m={sidebar_position:9,title:"String to Time"},d=void 0,s={unversionedId:"code-snippets/string2time",id:"code-snippets/string2time",isDocsHomePage:!1,title:"String to Time",description:"This command allows you to parse string to time, in a human friendly way.",source:"@site/docs/code-snippets/string2time.md",sourceDirName:"code-snippets",slug:"/code-snippets/string2time",permalink:"/code-snippets/string2time",editUrl:"https://github.com/yagpdb-cc/yagpdb-cc/edit/master/website/docs/code-snippets/string2time.md",version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"String to Time"},sidebar:"tutorialSidebar",previous:{title:"Snowflake to Time",permalink:"/code-snippets/snowflake2time"},next:{title:"Get Username Color",permalink:"/code-snippets/get-username-color"}},l=[],p={toc:l};function u(e){var t=e.components,n=(0,r.Z)(e,a);return(0,o.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This command allows you to parse string to time, in a human friendly way.",(0,o.kt)("br",{parentName:"p"}),"\n","Recommended usage: As a part of a Larger Command. Can also be used standalone with -",(0,o.kt)("br",{parentName:"p"}),"\n","",(0,o.kt)("strong",{parentName:"p"},"Trigger Type:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"Command"),(0,o.kt)("br",{parentName:"p"}),"\n","",(0,o.kt)("strong",{parentName:"p"},"Trigger:")," ",(0,o.kt)("inlineCode",{parentName:"p"},"time")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Usage:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"String to be converted is fed to -> ",(0,o.kt)("inlineCode",{parentName:"li"},"$timeString")),(0,o.kt)("li",{parentName:"ul"},"Converted time is available in variable -> ",(0,o.kt)("inlineCode",{parentName:"li"},"$timeConverted"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Supported Syntax:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Date: Format 1: ",(0,o.kt)("inlineCode",{parentName:"li"},"dd/mm/yyyy")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"dd.mm.yyyy")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"dd-mm-yyyy")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"dd,mm,yyyy")),(0,o.kt)("li",{parentName:"ul"},"Format 2: String format with year mentioned with 4 digits and both short and long month names supported. Date components (i.e day , month , year) need not be present together. eg: ",(0,o.kt)("inlineCode",{parentName:"li"},"12 Feb 11:50 am")," , ",(0,o.kt)("inlineCode",{parentName:"li"},"2020")," is supported."),(0,o.kt)("li",{parentName:"ul"},"Format 3: ",(0,o.kt)("inlineCode",{parentName:"li"},"Today")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"tomorrow")," is supported.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"TimeZone:")," By default timezone is UTC. If user has timezone set using ",(0,o.kt)("inlineCode",{parentName:"p"},"setz")," command, timezone adjustment is also possible. UTC time is parsed if explicitly specified UTC in this case."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Time:")," Time is mentioned as ",(0,o.kt)("inlineCode",{parentName:"p"},"hh:mm:ss")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"hh:mm")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"hh"),". May or may not be followed by AM or PM."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'{{/*\n  This command allows you to parse string to time, in a human friendly way.\n  Recommended usage: As a part of a Larger Command. Can also be used standalone with -\n    Trigger: Command trigger with trigger `time`\n\n  Usage:\n      String to be converted is fed to -> $timeString\n      Converted time is available in variable -> $timeConverted\n\n      Supported Syntax:\n      Date: Format 1:  dd/mm/yyyy or dd.mm.yyyy or dd-mm-yyyy or dd,mm,yyyy\n            Format 2:  String format with year mentioned with 4 digits and both short and long month names supported. Date components (i.e day , month , year) need not be present together. eg: 12 Feb 11:50 am , 2020 is supported.\n            Format 3:  Today and tomorrow is supported.\n\n      TimeZone: By default timezone is UTC. If user has timezone set using "setz" command, timezone adjustment is also possible. UTC time is parsed if explicitly specified UTC in this case.\n\n      Time: Time is mentioned as hh:mm:ss or hh:mm or hh. May or may not be followed by AM or PM.\n\n  Credits: Developed by Satty#9361\n*/}}\n\n{{/* CONFIGURATION VALUES START */}}\n{{/*String to be converted is fed to $timeString variable*/}}\n{{ $timeString := .StrippedMsg }}\n{{/* can be any string variable / string data but should contain only the time in the formats mentioned */}}\n{{/* CONFIGURATION VALUES END */}}\n\n{{/* Variable Declarations */}}\n{{ $dTime := sdict "Day" currentTime.Day "Month" (toInt (printf "%d" currentTime.Month)) "Year" currentTime.Year  "Hour" currentTime.Hour "Min" currentTime.Minute "Sec" currentTime.Second }}\n{{ $time := sdict "Day" $dTime.Day "Month" $dTime.Month "Year" $dTime.Year "Hour" 0 "Min" 0 "Sec" 0  }}\n{{ $dateSet := false }} {{ $timeSet := false }}\n{{ $timeConverted := 0 }}\n{{ $months := sdict\n    "jan" 1\n    "feb" 2\n    "mar" 3\n    "apr" 4\n    "may" 5\n    "jun" 6\n    "jul" 7\n    "aug" 8\n    "sep" 9\n    "oct" 10\n    "nov" 11\n    "dec" 12\n }}\n\n{{/* Actual Code */}}\n{{ $timeString = lower $timeString }}\n{{/* Fetching Dates */}}\n{{/* Fetching dates written in format dd.mm.yyyy or dd/mm/yyyy or dd-mm-yyyy or dd,mm,yyyy */}}\n{{ with reFindAllSubmatches `((\\s|^)((\\d{1,2})(\\-|\\.|\\/|\\,)(\\d{1,2})(\\-|\\.|\\/|\\,)(\\d{1,4}))(\\s|$))` $timeString }}\n      {{ $time.Set "Day" (toInt (index . 0 4)) }}\n      {{ $time.Set "Month" (toInt (index . 0 6)) }}\n      {{ $time.Set "Year" (toInt (index . 0 8)) }}\n      {{ $dateSet = true }}\n{{ else }}\n\n{{/* Fetching dates written as a string with both long or short month names supported. Date , Month and Year need not be present together but year must be written in full form(with 4 digits) eg: 20 sept 1am ,2019 is supported */}}\n     {{ with (reFindAllSubmatches `(?:[^a-z]|^)(jan((uary)?)|feb((ruary)?)|mar((ch)?)|apr((il)?)|may|jun(e?)|jul(y?)|aug((ust)?)|sep((t(ember)?)?)|oct((ober)?)|nov((ember)?)|dec((ember)?))(?:[^a-z]|$)` $timeString) }}\n     {{ $time.Set "Month" ($months.Get (slice (index . 0 1) 0 3)) }}\n     {{ $temp:= reReplace `(([^:]|^)((\\d+)((:(\\d+)){1,2}))((\\s?(am|pm))?))|(((\\d+))(\\s?(am|pm)))` $timeString "" }}\n     {{ with (reFindAllSubmatches `(?:\\D|^)(\\d{1,2})(?:\\D|$)` $temp) }}\n        {{ $time.Set "Day" (toInt (index . 0 1)) }}\n     {{ end }}\n     {{ with (reFindAllSubmatches `(?:\\D|^)(\\d{4})(?:\\D|$)` $temp) }}\n        {{ $time.Set "Year" (toInt (index . 0 1)) }}\n     {{ end }}\n     {{ $dateSet = true }}\n     {{ end }}\n{{ end }}\n\n{{/* Fetching dates specified as today or tomorrow and assigning default values to invalid dates */}}\n{{ if $dateSet }}\n{{ if not $time.Day }}{{ $time.Set "Day" $dTime.Day }}{{ end }}\n{{ if not $time.Month }}{{ $time.Set "Month" $dTime.Month }}{{ end }}\n{{ if not $time.Year }}{{ $time.Set "Year" $dTime.Year }}{{ end }}\n{{ else }}\n    {{ with reFind `(today)|(tomorrow)` $timeString }}\n        {{ if eq . "tomorrow" }}\n            {{ $time.Set "Day" (add $dTime.Day 1) }}\n        {{ end }}\n    {{ end }}\n{{ end }}\n\n{{/* Fetching time specified as hh:mm or hh:mm:ss or hh. Can be followed by am/pm as well. */}}\n{{ with reFind `(([^:]|^)((\\d+)((:(\\d+)){1,2}))((\\s?(am|pm))?))|(((\\d+))(\\s?(am|pm)))` $timeString }}\n    {{ with reFindAllSubmatches `(\\d+)` . }}\n        {{ $time.Set "Hour" (toInt (index . 0 0)) }}\n        {{ if (gt (len .) 1) }}\n            {{ $time.Set "Min" (toInt (index . 1 0) ) }}\n        {{ end }}\n        {{ if (gt (len .) 2) }}\n            {{ $time.Set "Sec" (toInt (index . 2 0)) }}\n        {{ end }}\n    {{ end }}\n    {{ with reFind `(am|pm)` . }}\n        {{ if and (eq $time.Hour 12) (eq . "am") }}\n            {{ $time.Set "Hour" 0 }}\n        {{ else if and (eq . "pm" ) (lt $time.Hour 12) }}\n            {{ $time.Set "Hour" (add $time.Hour 12) }}\n        {{ end }}\n    {{ end }}\n    {{ $timeSet = true }}\n{{ end }}\n\n{{/* Setting time to current time when both explicit date and time setting was not done */}}\n{{ if and (not $timeSet) (not $dateSet) }}\n    {{ $time.Set "Hour" $dTime.Hour }}\n    {{ $time.Set "Min" $dTime.Min }}\n    {{ $time.Set "Sec" $dTime.Sec }}\n{{ end }}\n\n{{/* Conversion to time.Time datatype */}}\n{{ $timeConverted = (newDate $time.Year $time.Month $time.Day $time.Hour $time.Min $time.Sec) }}\n\n{{/*timezone adjustment - Remove if you only want UTC times*/}}\n{{ if and (or $timeSet $dateSet) (not (reFind `([^a-z]|^)utc([^a-z]|$)` $timeString )) }}\n    {{ $TimeHour := .TimeHour }}\n    {{ with (reFind `(\\-)?\\d+(:\\d+)?` (exec "setz -u") ) }}\n        {{ $timeConverted = $timeConverted.Add (toDuration (mult -1.0 (toFloat (reReplace ":" . ".")) $TimeHour)) }}\n    {{ end }}\n{{ end }}\n')))}u.isMDXComponent=!0}}]);